Tutorial:
https://www.youtube.com/watch?v=xJAfLdUgdc4&ab_channel=WaelYasmina

NPM:
https://www.npmjs.com/package/three

Start: 12Jun2024
End:

Notes:
Going to start here, just to understand the basics and then get into projects, 
First create project file, install a bundler through NPM, 
'npm init -Y' #creates package.json
'npm install parcel --save-dev' or 'npm install parcel -g' #global install or use something like webpack
'npm install three' #will install threeJS, install after parcel
next, create a 'src' foldoer with 'js' 'script.js' and 'index.html'
<script src="./js/scripts.js" type="module"> #notice how the type is set to module and not script
import * as THREE from 'three'; #import all from threeJS
const renderer = new THREE.WebGLRenderer(); #next we need create an instance of the webGL renderer - a tool which ThreeJS uses to allocate space on a webpage, where you can add and animate 
renderer.setSize(window.innerWidth, window.innerHeight); #width and height as arguments, this will take up the full page using the .innerWidth and Height properties, this is basically a canvas element
document.body.appendChild(renderer.domElement); #inject that space into the page
'parcel ./src/index.html' #will bundle your newly created page, will also refresh the page every time you save, will create a 'dist' folder
<style>body { margin: 0 }</style> # to get rid of the scrollbars, set the margin to zero, will need to do this if your canvas is the full size of the screen

X,Y,Z = 3D, 3 Axis, corodinates, cartesian Coords, 
Set the sean(scene) - you will need a camera, and components (lights, actor, objects)
You need to create a scene(sean) by creating an instance of the sean(scene) class, then choose a camera, to create an instance, then add elements to the scene
2 types of cameras = 1st: Perspective camera(same as RL camera), and autographic camera(used to render 2D seans(scenes))
to create a perspective camera in ThreeJS, you need X4 Values = Vertical Field of View(Max Angle), Aspect Ratio(proportion of width and height w/h), Near and Far Clipping planes(bounds of what can be sean(seen)/rendered), 
x6 Values for Autographic Camera = Left, Right, Top, Bottom Edges(or limits of the scene(sean)), Near and Far Clipping Planes(also limits of the scene(sean) but distance) 
The perspective of the ball changes as the ball get's closer or farther away from the camera using a perspective camera, with an autographic camera, it does not, depth does not matter for autographic

#to create a new scene, we need x4 Arguments, talked about above
const scene = new THREE.Scene(); 
const camera = new THREE.PerspectiveCamera(
  75, #Field of view depends on what you are working on(generally between 40-80 is good)
  window.innerWidth / window.innerHeight, #aspect ratio, width / height 
  0.1 #near clipping plane
  1000 #far clipping plane
); 
renderer.render(scene, camera); #will render the scene(sean) using the newly created scene(sean) and camera as arguments
const axesHelper = new Three.AxesHelper(5) #Axes Helper, a tool that serves as a guide, introduces the 3D coordinates system into the scene, the '5' represenets the length of the Axes
scene.add(axesHelper); #will add the newly created axesHelper to the scene(sean)
camera.position.z = 5; #the camera is set to the point (0,0,0) by default, we will move the camera up 5 on the Z coordinate
camera.position.y = 2; #will move the camera up 2 on the Y coord
camera.position.set(0, 2, 5); #will set the camera on the scene, first element is X axis, (X, Y, Z)

10:00=============================================================================================================================================================================================================================
const boxGeometry = new THREE.BoxGeometry(); #will create a new naked box object
const boxMaterial = new THREE.MeshBasicMaterial({color: 0x00FF00}); #new mesh object of color <-that
const box = new THREE.Mesh(boxGeometry, boxMaterial); #creates a new box object that has a mesh
scene.add(box); #adds the new box object to the scene(sean)
box.rotation.x = 5; #Geometric Transformation, after creating our objects we can transform them, such as a rotation, 
box.rotation.y = 5; #transformation rotation of y axis by 5
function animate() {box.rotation.x += 0.01; box.rotation.y += 0.01; renderer.render(scene, camera); } #will create an animation that rotates a cube
renderer.setAnimationLoop(animate); #pass our above new function as an argument to animate the cube
function animate(time) {box.rotation.x = time / 1000; box.rotation.y = time / 1000; renderer.render(scene, camera); } #control the speed of animation by using 'time' as an argument and variable for rotation

import {OrbitControls} from 'three/examples/jsm/controls/OrbitCOntrols.js'; #will allow us to control the camera angle using the mouse buttons 
const orbit = new OrbitControls(camera, renderer.domElement); #we need to create an instance in order to use it
orbit.update() #call the update method every time you change the position of the camera - this is very important - now you can rotate the camera around the cube object, left click rotates, scroll in/out with wheel, right up/down

The creation of an element in ThreeJS happens in 3 phases, 1) Creation of Geometry/Skeleton, 2) Creation of the Material/Mesh/Skin 3) Cover the Geometry with the Material/Mesh/Skin
Some materials require more resources/demands on the system and you should be careful which material you pick in case someone is using your site on a potatoe
If you use the 'THREE.MeshBasicMaterial' it will appear without a light source - 'MeshStandardMaterial' 'MeshLambartMaterial' both require a lightsource - check documentASean to know the full list

const planeGeometry = new THREE.PlaneGeometry(30, 30); #create a 30x30 flat plane geometry
const planeMaterial = new THREE.MeshBasicMaterial({color: 0xFFFFFF}); #create a color mesh
const plane = new THREE.Mesh(planeGeometry, planeMaterial); #add geometry and mesh together
scene.add(plane); #add our new mesh to the scene
when you rotate the plane to the side, the material disapears - to fix this you need to add the side property and change it to 3 double side, like below
const planeMaterial = new THREE.MeshBasicMaterial({color: 0xFFFFFF, side: THREE.DoubleSide, });

const gridHelper = new THREE.GridHelper(30, 100); #creates a grid of size (30) with (100) squares divided into it the (30, 100) is optional
scene.add(gridHelper); #adds a grid to the scene

const sphereGeometry = new THREE.SphereGeometry(4);
const sphereMaterial = new THREE.MeshBasicMaterial({color: 0x0000FF, wireframe: true}); #wireframe will allow us to see the polygons(is that the right word?) dodecahedrons(?) the wire frame outline.
const spehere = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(sphere); # will add a blue sphere to the center of the scene, with wireframe = WELCOME TO THE BLUE THUNDERDOME

the quality of the mesh depends upon the number of faces on the entity, if you increase the number of segments, you can increase the 'roundness' of the object
const sphereGeometry = new THREE.SphereGeometry(4, 10, 10); #decreased the proporSeans of the sphere, and way less rounded due to the reduced amount of faces on the segments,

sphere.position.x = -10; #will repositionthe sphrere into the -10th(?) X position
sphere.position.set(-10, 10, 0) #will reposition (X, Y,Z) (-10, 10, 0) - you don't have to set each axis individually like above, do all 3 at once

20:00================================================================================================================================================================================================================================
Debugging and playing with values to get the perfect position of an element and it's color can take a long time, there is a tool you can utilize to solve this problem : 'dat.gui'































