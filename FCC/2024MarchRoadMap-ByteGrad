Web Developer Roadmap(March 2024):
https://www.youtube.com/watch?v=EzTxYQmU8OE&t=26s&ab_channel=ByteGrad
  AI Copilots / Typescript + Zod / TailwindCSS / Next.JS AppRouter / 

Fundamentals: 
HTML + Semantic HTML
CSS: 
Box Model / FlexBix / Grid / Animations & Transitions / Responsiveness(Media Queries)
JS: 
Variables / Arrays / Objects / Functions(Arrows vs Traditional) / Fetch API / Asynchronous Code(Promises Vs Async/await) / DOM + Web Platform (Events/manipulation)

FrontEnd:
React(Vite) / Components / Props / Hooks (useState / useEffect / Custom Hooks ) State Management (Context API vs Zustand vs Redux) Styling(Tailwind CSS) Patterns and Best Practices(reusability/state in URL/etc)
Typescript:
Basic Types / Inference / Type vs Interface / Generics

Backend/FullStack:
Next.JS / ServerComponents / Server Actions / Caching / SSR / SSG / Patterns and Best Practices / Data Fetching / ServerSide Validation / Avoid Leaks 
Seperate Backend:
Node.JS / Express / Nest.JS / PHP-Laravel / Java(Spring) / Ruby on Rails / Go
Databases:
SQL(Postgres / MySQL / SQLite / NoSQL(Mongo) / ORM(Prisma/Drizzle/Mongoose) / Hosted DB Services(Supabase/Firebase/Vercel)

HTML + Semantic HTML<Semantic Tags = don't just use divs everywhere
CSS = Box Model is very imporant (Margin + Border + Padding)
FlexBox = What you use 99% of the time, when it comes to layouts
Animations/Transitions = on hover effects
Responsiveness = everything you build should look good regardless of screen size(media queries)
JS: Variables (let vs const vs var)
JS: Arrays = are lists/collections of items (methods .map(), .forEach(), .push() 
JS: Objects = {} whenever you have something you want to represent in your code, you can use an object {} JSON, represent entities in code
JS: Functions(Arrows vs Traditional) = () => {} , instead of writing function in your code, you can just write an arrow
JS: Fetch API = fetch() built in fetch API which gives you a promise, typically you don't need to create your own promises, you only consume promises p.then()
JS: Asynchronous Code(Promises Vs Async/await) = await p, typically async await functions are used over promises today
JS: DOM + Web Platform (Events/manipulation) = Document Object Model / Local Storage / How URL's work / how to communicate with a server

FrontEnd:
React(Vite) = Vite is essentially a replacement of Create React App , 
Components = Written in CapitalCase, essentialy just a function(export default function PetFormBtn({ actionType}: PetFormBtnProps) {return ()}, allows you to reuse your code instead of rewriting it, use props to make changes
Props / Hooks (useState / useEffect / Custom Hooks = React has Hooks you UseState= if a piece of data you want to change over time, useEffect = if you want to go outside your react app, reach out to a sever or local storage
  Custom Hooks = a utility function / Props = properties to use in other parts of your app or components
  Sometimes it's better to not use state and just make it part of the URL
State Management (Context API vs Zustand vs Redux) = State Management Solution / Context API = built in state mgmt solution / Zustand+Redux = other state mgmt solutions
Styling(Tailwind CSS) = Great for styling
Patterns and Best Practices(reusability/state in URL/etc) = components are reuseable, ?price=10000 #as part of URL would only show items with a price below 10,000$
Routing = comes from a full stack framework like nextJS / reactquery / server components

Typescript = Forces you to be much more precise with your types(strongly type JS), you don't need to learn it seperately, just enable it in your apps as you build
Basic Types = string / boolean / number /null
Inference = TS can detect pretty easily if something is a string a number or a boolean, you don't have to tell it
Type vs Interface = look it up
Generics = most commonly used when you create a custom hook

Backend/FullStack:
Next.JS = A React Framework, Has built in routing through the file system, also has server components and server actions, very page focused, will create pages out of components
ServerComponents = traditional backend code would be written with a webserver with an API end point to update data, which you can do with a server component, for performance benefits
Server Actions = for developer benefits, don't need to create API endpoints, can set up just a server action to handle data
Caching = NextJS uses caching automatically, increase performance
SSR / SSG = Static Site Generation = takes componenets and creates HTML out of it at build, creates HTML out of react components at request time
Patterns and Best Practices :
  Data Fetching = typically don't use react query for this anymore, use a server component, submit through server action, 
  ServerSide Validation = validate the data you get from a client with something like zod, because you never know what a client is going to send you
  Avoid Leaks = very easy to leak sensitive data, don't do that

Seperate Backend(Whenever you have some compute heavy or special task, it's better to do it in a seperate backend): 
Node.JS = Uses HS and Typescript, most popular for API endpoints
Express =
Nest.JS = 
PHP-Laravel = Popular with wordpress
Python(django) = Web framework for python,
Java(Spring) = 
Ruby on Rails = 
Go = 

Databases:
SQL(Postgres / MySQL / SQLite = SQLite = easiest to set up, only requires a single file in your file system, can not deploy to a serverless platform(like vercel), use during development then change to PostGres

NoSQL(Mongo) = 
ORM(Prisma/Drizzle/Mongoose) = will abstract away the differences between a SQL and NoSQL DB(models, etc)
Hosted DB Services(Supabase/Firebase/Vercel) = Do you like spending money and not scaling? Use these







